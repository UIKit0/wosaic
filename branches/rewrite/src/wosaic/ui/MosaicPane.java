/**
 * 
 */
package wosaic.ui;

import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Image;
import java.awt.Rectangle;

import javax.swing.JComponent;

import wosaic.utilities.Pixel;

/**
 * A UI element that will display a visual representation of the underlying
 * Mosaic.
 * 
 * @author scott
 */
public class MosaicPane extends JComponent {

	/**
	 * A UI component holding the visual representation of one tile.
	 * 
	 * @author scott
	 */
	public class MosaicPaneTile extends JComponent {

		/**
		 * serialVersionID generated by Eclipse.
		 */
		private static final long serialVersionUID = -1548498823961157782L;

		/**
		 * The image representing this individual Tile in the mosaic
		 */
		protected Pixel thePixel = null;

		/**
		 * Default constructor.
		 */
		public MosaicPaneTile() {
			super();
			
			// Decrease painting cost by "agreeing" to paint entire rectangle.
			setOpaque(true);
		}

		/**
		 * Paint the current image onto our graphics
		 * 
		 * @see javax.swing.JComponent#paintComponent(java.awt.Graphics)
		 */
		@Override
		public void paintComponent(final Graphics grx) {
			if (thePixel != null)
			//	grx.drawImage(theImage, 0, 0, getWidth(), getHeight(), this);
				grx.drawImage(thePixel.getScaledImage(getWidth(), getHeight()), 0, 0, null);
			else
				grx.clearRect(0,0,getWidth(), getHeight());
			
			//FIXME: Should the call to super come before or after?
			super.paintComponent(grx);
		}

		/**
		 * Change the Image that represents this tile
		 * 
		 * @param pixel
		 *            The new Pixel
		 */
		public void UpdateTilePixel(final Pixel pixel) {
			thePixel = pixel;
			//TODO: Use the parametrized version of repaint to only paint the
			// the bounding rectangle.
			repaint();
		}
	}

	/**
	 * serialVersionID generated by Eclipse.
	 */
	private static final long serialVersionUID = -8587141268793103714L;

	/**
	 * A grid representing each tile of the Mosaic
	 */
	protected MosaicPaneTile[][] TileGrid;

	/**
	 * Default constructor.
	 * 
	 * @param width
	 *            The Mosaic resolution width
	 * @param height
	 *            The Mosaic resolution height
	 */
	public MosaicPane(final int width, final int height) {
		super();

		// This makes all painting happen off-screen first, and then is copied
		// to the screen. Should help with the large number of updates.
		setDoubleBuffered(true);
		
		setGrid(width, height);
	}
	
	/**
	 * Default constructor.
	 */
	public MosaicPane() {
		super();

		// This makes all painting happen off-screen first, and then is copied
		// to the screen. Should help with the large number of updates.
		setDoubleBuffered(true);

	}
	
	public void setGrid(final int width, final int height) {
		if (TileGrid != null)
			TileGrid = null;
		System.gc();
		
		// Setup our layout
		setLayout(new GridLayout(height, width));
		
		// initialize our tiles and add them to the grid
		TileGrid = new MosaicPaneTile[height][width];
		for (int h = 0; h < height; h++)
			for (int w = 0; w < width; w++) {
				TileGrid[h][w] = new MosaicPaneTile();
				add(TileGrid[h][w]);
			}
		invalidate();
	}

	/**
	 * Update the Image on a specific tile
	 * 
	 * @param x
	 *            The row of the tile to update
	 * @param y
	 *            The column of the tile to update
	 * @param pixel
	 *            The new pixel
	 */
	public void UpdateTile(final int x, final int y, final Pixel pix) {
		TileGrid[x][y].UpdateTilePixel(pix);
	}
}
